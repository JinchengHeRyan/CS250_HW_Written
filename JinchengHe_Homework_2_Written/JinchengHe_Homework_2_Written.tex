\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[margin=1in]{geometry}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{arydshln}
\usepackage{mathtools}
\usepackage{cases}
\usepackage{listings}
\usepackage[numbered]{mcode}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{subfigure}

\usepackage{blindtext}
\usepackage{amssymb}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

\urlstyle{same}

%\newtheorem{theorem}{Theorem}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\title{CS 250 - Computer Architecture \\ Homework 2 Written}
\author{Jincheng He Email: jincheng.he@dukekunshan.edu.cn}
\date{October 11, 2021}

\begin{document}

    \maketitle


    \section{Q1 MIPS Instruction Set}
    \begin{enumerate}
        \item[(a)] What MIPS instruction is this? 0x022a4822

        The binary representation is: 0000 0010 0010 1010 0100 1000 0010 0010. So it should be 000000 10001 01010 01001 00000 100010. So Rs is \$s1, Rt is \$t2, Rd is \$t1.
        Based on Sh and Func, we can know it is sub.

        So the MIPS instrunction should be: sub \$t1, \$s1, \$t3.
        \item[(b)] What is the binary representation of this instruction lw \$t0, 8(\$t2)?

        The binary should be 100011 Rs Rt Immed. Rs is \$t2, which is 01010, Rt is \$t0, which is 01000, Immed is 8, which is 0000000000001000. So the binary representation should be: 100011 01010 01000 0000000000001000.
    \end{enumerate}


    \section{Q2. C compilation and MIPS assembly language}
    \begin{enumerate}
        \item[(a)] How many total instructions are in each of the two versions?

        For the version of -O0, there are 57 instructions in total.

        For the version of -O3, there are 32 instructions in total.
        \item[(b)] How many memory accesses (loads and stores) are in each of the two versions?

        For the version of -O0, there are 7 load words and 3 store words.

        For the version of -O3, there are 2 load words and 2 store words.
        \item[(c)] Which version of the code uses more registers?

        The version of -O3 uses more registers.
        \item[(d)] How does the mapping of unoptimized code to C differ from the optimized code?

        The unoptimized code is "stripes", and the optimized code is "blocks".
        This means the unoptimized code would translate the C code to assembly code line by line, while the optimized code would "think" together within lines.
        \item[(e)] Based on the above, what are some general strategies you suspect the optimizer takes to improve performance?

        Use less instructions, less memory accesses, use more registers to avoid too many memory accesses, and consider the whole program together to share something in the middle, and the code would be "stripes".
    \end{enumerate}


\end{document}